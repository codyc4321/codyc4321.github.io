<head>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>

    <style>
        .container {
            position: absolute;
            top: 9%;
            bottom: 9%;
            left: 15%;
            right: 15%;
            border: 2px solid;
        },
        .code {
            background: #f4f4f4;
            border: 1px solid #ddd;
            border-left: 3px solid #f36d33;
            color: #666;
            page-break-inside: avoid;
            font-family: monospace;
            font-size: 15px;
            line-height: 1.6;
            margin-bottom: 1.6em;
            max-width: 100%;
            overflow: auto;
            padding: 1em 1.5em;
            display: block;
            word-wrap: break-word;
        }
    </style>
</head>

<body>
    <div class="container">
        <p>Unit testing is a method for testing software that looks at the smallest testable pieces of code, called units, which are tested for correct operation.
            By doing unit testing, we can verify that each part of the code, including helper functions that may not be exposed to the user,
            works correctly and as intended.
        </p>
        <p>
            The idea is that we are independently checking each small piece of our program to ensure that it works.
            This contrasts with regression and integration testing, which tests that the different parts of the program work well together and as intended.
        </p>
        <p>
            Unit tests verify that the methods you write work as corrected in the future, mainly to allow you to make changes to the code and
            automatically verify your code still works after you change it.
        </p>
        <p>
            This allows you to work quickly and efficiently as the project grows, as making significant changes to a method written weeks ago
            only takes about 5-10 seconds to verify.
        </p>
        <p>
            Well-written unit tests can save several hours of often tedious and frivolous manual testing per week, such as walking through the debugger or writing throwaway print statements.
        </p>
        <p>
            If a project grows into a very large and complex system, with numerous collaborators at the same time, unit tests can even save dozens,
            or hundreds of hours of time, with a very minimal amount of investment compared with how much time debugging would take \
            if you didn't have tests.
        </p>
        <p>
            Would you rather spend 1 hour writing creative tests and learning while documenting your code, or 3 hours of boring debugger walkthroughs?
        </p>
        <p>
            The time unit tests save you can grow exponentionally as the project codebase grows rapidly.
        </p>
        <p>
            Unit tests are self-documenting: if the project gets moved to a new teammate for maintainence, they can become productive immediately
            by merely running your tests and seeing what they broke, or even just reviewing your tests as soon as they download the code.
        </p>
        <p>
            This is because unit tests show a result, and an expectation, and the hard-coded expecation statements document what the method was intended to do.
        </p>
        <p>
            Another key benefit of unit tests is that they help easily isolate errors. <br/>
            Imagine running the entire project and receiving a string of errors. How would we go about debugging our code?
        </p>
        <p>A test failure means the code can run, but the test result didn't match the expecation we gave the test.</p>
        <p>An error running the tests means the code the test relies on actually cannot run, such as typos like:</p>
        <pre>
            <code>
                def myfunction()):;
            </code>
        </pre>
    </div>
</body>